#!/usr/bin/env python3

import asyncio
import functools
import logging
import signal
import sys
import time

from uchroma import __version__
from uchroma.blending import BlendOp
from uchroma.cmd import UChromaConsoleUtil
from uchroma.color import Splotch
from uchroma.led import LED
from uchroma.types import FX
from uchroma.util import enumarg, EnumType


logging.basicConfig(stream=sys.stdout, level=logging.INFO)


class UChromaTool(UChromaConsoleUtil):


    def _add_subparsers(self, sub):
        self._brightness_sub = self._add_brightness_options(sub)
        self._anim_sub = self._add_anim_options(sub)
        self._fx_sub = self._add_fx_options(sub)
        self._led_sub = self._add_led_options(sub)

        test = sub.add_parser('test', help='Test commands')
        test.add_argument('path', metavar='Device path', type=str,
                          help='Test if path is a uChroma device (udev)')
        test.set_defaults(func=self._test_device)


    def _add_fx_options(self, sub):
        fx = sub.add_parser('fx', help='Lighting effects')
        fx.add_argument("-d", "--device", type=str,
                        help='HID device to use (/dev/hidrawX or USB identifier)')
        fx.add_argument('--list', action='store_true',
                        help='List supported effects')
        fx.add_argument('fxtype', metavar='EFFECT TYPE', type=str, nargs='?',
                        help='Effect type to activate')

        custom_group = fx.add_argument_group('Effect customization options')
        custom_group.add_argument('-s', '--speed', type=int, help='Effect speed')

        color = custom_group.add_mutually_exclusive_group()
        color.add_argument('-x', '--splotch', type=str,
                           choices=[x.name.lower() for x in Splotch],
                           help='Predefined color pairs')
        color.add_argument('-c', '--color', type=str, action='append',
                           help='Color name or hexcode')
        color.add_argument('-z', '--size', type=int,
                           help='Size parameter for some effects')

        fx.set_defaults(func=self._fx_parser)
        return fx


    def _add_brightness_options(self, sub):
        bright = sub.add_parser('brightness', help='Set/get brightness level')
        bright.add_argument("-d", "--device", type=str,
                            help='HID device to use (/dev/hidrawX or USB identifier)')

        bright.add_argument('level', metavar='BRIGHTNESS', type=float, nargs='?',
                            help='Brightness level to set (0-100)')

        bright.set_defaults(func=self._brightness_parser)
        return bright


    def _add_led_options(self, sub):
        # FIXME: Per-device LEDs
        led = sub.add_parser('led', help='LED control')
        led.add_argument("-d", "--device", type=str,
                         help='HID device to use (/dev/hidrawX or USB identifier)')

        led.add_argument('led_type', metavar='LED type', type=str,
                         choices=[x.name.lower() for x in LED.Type],
                         help='Type of LED to control')
        led.add_argument('-i', '--info', action='store_true', help='Get status of LED')

        ledx = led.add_argument_group('LED attributes')
        ledx.add_argument('-s', '--state', type=bool,
                          help='State for the LED')
        ledx.add_argument('-m', '--mode', type=str,
                          choices=[x.name.lower() for x in LED.Mode],
                          help='Mode for the LED')
        ledx.add_argument('-c', '--color', type=str,
                          help='RGB color for the LED')
        ledx.add_argument('-b', '--brightness', metavar='BRIGHTNESS', type=float,
                          help='Set brightness (0-100)')
        led.set_defaults(func=self._led_parser)
        return led


    def _add_anim_options(self, sub):
        anim = sub.add_parser('anim', help='Animation control')
        anim.add_argument("-d", "--device", type=str,
                          help='HID device to use (/dev/hidrawX or USB identifier)')
        anim.add_argument('-n', '--name', type=str, action='append',
                          help='Animation to add (class)')
        anim.add_argument('-m', '--module', type=str,
                          help='Module to search for animation')
        anim.add_argument('-b', '--blend', type=str,
                          choices=BlendOp.get_modes(),
                          help='Blending mode (multiple layers only)')
        anim.set_defaults(func=self._anim_parser)
        return anim


    @staticmethod
    def _get_splotch(args):
        if args.splotch is None:
            return None
        return Splotch[args.splotch.upper()]


    @staticmethod
    def _get_color(args, num):
        if args.color is None:
            return None

        if len(args.color) <= num:
            return None

        return args.color[num]


    def _test_device(self, args):
        if args.path.startswith('/dev/hidraw'):
            if args.path not in self._dm.devices:
                sys.exit(1)
        elif args.path.startswith('/dev/bus/usb'):
            found = False
            ids = args.path.split('/')
            match = '%04x:%04x:' % (int(ids[-2]), int(ids[-1]))
            for key in self._dm.devices:
                if key.startswith(match):
                    found = True
                    break

            if not found:
                sys.exit(1)

            print('UCHROMA_DEVICE=1')
            sys.exit(0)


    def _list_fx(self, driver):
        if driver.supported_fx is None:
            self.print_err('No supported effects found.')
            sys.exit(1)

        print('\nSupported effects:\n')
        for fx in sorted(driver.supported_fx):
            print('%20s     %s' % (fx.name.lower(), fx.description))


    def _fx_parser(self, args):
        with self.get_driver(args) as driver:
            if args.list or args.fxtype == 'list':
                self._list_fx(driver)
                sys.exit(0)

            if args.fxtype is None:
                self._fx_sub.print_help()
                self._list_fx(driver)
                sys.exit(1)

            if driver.has_fx(args.fxtype):
                if self._activate_fx(args.fxtype, args, driver):
                    sys.exit(0)

                self.print_err('Failed to activate effect')
                sys.exit(1)

            self.print_err('Unsupported effect: %s\n' % args.fxtype)
            self._list_fx(driver)
            sys.exit(0)


    @enumarg(FX)
    def _activate_fx(self, fx: EnumType, fx_args, driver) -> bool:

        if fx == FX.BREATHE:
            return driver.breathe(color1=UChromaTool._get_color(fx_args, 0),
                                  color2=UChromaTool._get_color(fx_args, 1),
                                  splotch=UChromaTool._get_splotch(fx_args))

        elif fx == FX.DISABLE:
            return driver.disable()

        elif fx == FX.FIRE:
            return driver.fire(color=UChromaTool._get_color(fx_args, 0),
                               speed=fx_args.speed)

        elif fx == FX.MORPH:
            return driver.morph(base_color=UChromaTool._get_color(fx_args, 0),
                                color=UChromaTool._get_color(fx_args, 1),
                                splotch=UChromaTool._get_splotch(fx_args),
                                speed=fx_args.speed)

        elif fx == FX.RAINBOW:
            return driver.rainbow(length=fx_args.size)

        elif fx == FX.REACTIVE:
            return driver.reactive(color=UChromaTool._get_color(fx_args, 0),
                                   speed=fx_args.speed)

        elif fx == FX.RIPPLE:
            return driver.ripple(color=UChromaTool._get_color(fx_args, 0),
                                 speed=fx_args.speed)

        elif fx == FX.RIPPLE_SOLID:
            return driver.ripple_solid(color=UChromaTool._get_color(fx_args, 0),
                                       speed=fx_args.speed)

        elif fx == FX.SPECTRUM:
            return driver.spectrum()

        elif fx == FX.STARLIGHT:
            return driver.starlight(color1=UChromaTool._get_color(fx_args, 0),
                                    color2=UChromaTool._get_color(fx_args, 1),
                                    splotch=UChromaTool._get_splotch(fx_args),
                                    speed=fx_args.speed)

        elif fx == FX.STATIC:
            return driver.static(color=UChromaTool._get_color(fx_args, 0))

        elif fx == FX.SWEEP:
            return driver.sweep(base_color=UChromaTool._get_color(fx_args, 0),
                                color=UChromaTool._get_color(fx_args, 1),
                                splotch=UChromaTool._get_splotch(fx_args),
                                speed=fx_args.speed)

        elif fx == FX.WAVE:
            return driver.wave()

        else:
            self.print_err('Support for this effect (%s) is not implemented' % fx_args.fxtype)
            sys.exit(1)

        return False


    def _led_parser(self, args):
        with self.get_driver(args) as driver:

            led = driver.get_led(LED.Type[args.led_type.upper()])
            if led is None:
                sys.exit(1)

            if args.info:
                led_type = None
                if led.led_type is not None:
                    led_type = led.led_type.name

                mode = None
                if led.mode is not None:
                    mode = led.mode.name

                print('type=%s,state=%s,color=%s,mode=%s,brightness=%f' \
                      % (led_type, led.state, repr(led.color), mode, led.brightness))

            else:
                if args.state is not None:
                    led.state = args.state

                if args.mode is not None:
                    led.mode = LED.Mode[args.mode.upper()]

                if args.color is not None:
                    led.color = args.color.lower()

                if args.brightness is not None:
                    if args.brightness < 0 or args.brightness > 100:
                        self.print_err("Brightness value must be between 0 and 100")
                        sys.exit(1)

                    led.brightness = args.brightness


    def _brightness_parser(self, args):
        with self.get_driver(args) as driver:
            if args.level is None:
                print('%f' % driver.brightness)

            else:
                if args.level < 0 or args.level > 100:
                    self.print_err('Brightness must be between 0 and 100')
                    sys.exit(1)

                driver.brightness = args.level


    def _anim_parser(self, args):
        def shutdown_asyncio(loop):
            loop.stop()


        with self.get_driver(args) as driver:
            mgr = driver.animation_manager
            if mgr is None:
                print_err('This device does not support animations.')
                sys.exit(1)

            module = 'uchroma.fxlib'
            if args.module is not None:
                module = args.module

            if args.name is None or len(args.name) == 0:
                self.print_err("Animation name is required")
                sys.exit(1)

            for name in args.name:
                cookie = mgr.add_renderer(name, module)
                if cookie is None:
                    self.print_err("Failed to create renderer")
                    sys.exit(1)

                print('Created layer: %s' % cookie)

            if not mgr.start(blend_mode=args.blend):
                self.print_err("Failed to start animation")
                sys.exit(1)

            loop = asyncio.get_event_loop()

            for sig in (signal.SIGINT, signal.SIGTERM):
                loop.add_signal_handler(sig, functools.partial(shutdown_asyncio, loop))

            try:
                loop.run_forever()
            finally:
                loop.run_until_complete(mgr.stop())

            loop.close()



if __name__ == '__main__':
    UChromaTool().run()
