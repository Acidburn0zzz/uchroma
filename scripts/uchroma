#!/usr/bin/env python3
# pylint: disable=protected-access, invalid-name
import functools
import logging
import re
import sys

from argparse import ArgumentParser
from collections import OrderedDict

from traitlets import HasTraits, Undefined

from uchroma import __version__
from uchroma.blending import BlendOp
from uchroma.cmd import UChromaConsoleUtil
from uchroma.color import ColorPair
from uchroma.dbus_utils import dbus_prepare
from uchroma.led import LED
from uchroma.traits import add_traits_to_argparse, dict_as_class_traits
from uchroma.util import ArgsDict, max_keylen


logging.basicConfig(stream=sys.stdout, level=logging.INFO)


class UChromaTool(UChromaConsoleUtil):


    def _add_subparsers(self, sub):
        self._brightness_sub = self._add_brightness_options(sub)
        self._anim_sub = self._add_anim_options(sub)
        self._fx_sub = self._add_fx_options(sub)
        self._led_sub = self._add_led_options(sub)
        self._dump_sub = self._add_dump_options(sub)


    def _add_dump_options(self, sub):
        dump = sub.add_parser('dump', help='Dump device info')
        dump.add_argument("-w", "--wide", action="store_true",
                          help="Wide output (don't truncate long lines")
        dump.set_defaults(func=self._dump_parser)
        return dump


    def _add_fx_options(self, sub):
        fx = sub.add_parser('fx', help='Lighting and effects', add_help=False)
        fx.add_argument('--list', action='store_true',
                        help='List supported effects')

        fx.set_defaults(func=self._fx_parser)
        return fx


    def _add_brightness_options(self, sub):
        bright = sub.add_parser('brightness', help='Set/get brightness level')
        bright.add_argument('level', metavar='BRIGHTNESS', type=float, nargs='?',
                            help='Brightness level to set (0-100)')

        bright.set_defaults(func=self._brightness_parser)
        return bright


    def _add_led_options(self, sub):
        # FIXME: Per-device LEDs
        led = sub.add_parser('led', help='LED control')
        led.add_argument('led_type', metavar='LED type', type=str,
                         choices=[x.name.lower() for x in LED.Type],
                         help='Type of LED to control')
        led.add_argument('-i', '--info', action='store_true', help='Get status of LED')

        ledx = led.add_argument_group('LED attributes')
        ledx.add_argument('-s', '--state', type=bool,
                          help='State for the LED')
        ledx.add_argument('-m', '--mode', type=str,
                          choices=[x.name.lower() for x in LED.Mode],
                          help='Mode for the LED')
        ledx.add_argument('-c', '--color', type=str,
                          help='RGB color for the LED')
        ledx.add_argument('-b', '--brightness', metavar='BRIGHTNESS', type=float,
                          help='Set brightness (0-100)')
        led.set_defaults(func=self._led_parser)
        return led


    def _add_anim_options(self, sub):
        anim = sub.add_parser('anim', help='Animation control')
        anim.add_argument("-d", "--device", type=str,
                          help='HID device to use (/dev/hidrawX or USB identifier)')
        anim.add_argument('--list', action='store_true',
                          help='List available renderers')
        anim.add_argument('-a', '--add', type=str, action='append',
                          help='Adds a new animation layer')
        anim.add_argument('-s', '--start', action='store_true',
                          help='Starts animation with the configured layers')
        anim.add_argument('-q', '--stop', action='store_true',
                          help='Stops the currently running animation')
        anim.add_argument('-c', '--clear', action='store_true',
                          help='Stop and clear the current animation settings')
        anim.add_argument('-m', '--modify', type=str, action='append',
                          help='Modify an existing animation layer')
        anim.add_argument('-b', '--blend', type=str,
                          choices=BlendOp.get_modes(),
                          help='Default blending mode (multiple layers only)')
        anim.set_defaults(func=self._anim_parser)
        return anim


    @staticmethod
    def _get_preset(args):
        if args.preset is None:
            return None
        return ColorPair[args.preset.upper()].name.lower()


    @staticmethod
    def _get_color(args, num):
        if args.color is None:
            return None

        if len(args.color) <= num:
            return None

        return args.color[num]


    def _show_traits(self, traits, indent=0):
        s_traits = sorted(OrderedDict(traits).items())

        for name, trait in s_traits:
            if name in ('description', 'hidden', 'background_color', 'blend_mode', 'opacity'):
                continue

            if trait.read_only or (hasattr(trait, 'write_once') and trait.write_once):
                continue

            trait_type = re.sub(r'Trait$', '', trait.__class__.__name__).lower()
            desc = 'No description available'

            if trait_type == 'caselessstrenum':
                trait_type = 'choice'
                desc = 'one of: %s' % ', '.join([x.lower() for x in sorted(trait.values)])
            elif hasattr(trait, 'info_text'):
                desc = trait.info_text


            constraints = []
            if hasattr(trait, 'min'):
                constraints.append('min: %s' % trait.min)
            if hasattr(trait, 'max'):
                constraints.append('max: %s' % trait.max)
            if hasattr(trait, '_minlen') and trait._minlen > 0:
                constraints.append('min length: %s' % trait._minlen)
            if hasattr(trait, '_maxlen') and trait._maxlen != sys.maxsize:
                constraints.append('max length: %s' % trait._maxlen)
            if hasattr(trait, 'default_value') and trait.default_value is not Undefined:
                constraints.append('default: %s' % trait.default_value)

            constraint_str = ''
            if len(constraints) > 0:
                constraint_str = '[' + (', '.join(constraints)) + ']'

            print('%*s| "%s" (%s): %s %s' % (indent, '', name, trait_type, desc, constraint_str))


    def _load_fx_traits(self, sfx):
        fx_traits = OrderedDict()
        for name, t_dict in sorted(sfx.items()):
            traits = dict_as_class_traits(t_dict)
            if 'hidden' in traits:
                if traits['hidden'].default_value:
                    continue
            desc = "No description available"
            if 'description' in traits:
                desc = traits['description'].default_value
            trait_data = {}
            trait_data['traits'] = traits
            trait_data['desc'] = desc
            fx_traits[name] = trait_data

        return fx_traits


    def _list_fx(self, fx_traits):
        if fx_traits is None or len(fx_traits) == 0:
            self.print_err('No supported effects found.')
            sys.exit(1)

        print('\nBuilt-in effects and arguments:\n')
        keylen = max_keylen(fx_traits)

        for name, trait_data in fx_traits.items():
            print('%*s | %s' % (keylen, name, trait_data['desc']))
            self._show_traits(trait_data['traits'], indent=keylen + 1)
            print('\n')


    def _fx_parser(self, args):
        driver = self.get_driver()

        sfx = driver.AvailableFX

        fxparser = ArgumentParser(description=self.description, conflict_handler='resolve')
        fxparser.add_argument('--list', action='store_true',
                              help='List supported effects')

        sub = fxparser.add_subparsers(title='Built-in effects', dest='fx_cmd')

        fx_traits = self._load_fx_traits(sfx)

        if args.list:
            self._list_fx(fx_traits)
            sys.exit(0)

        # turn all traits into argparse commands
        for name, trait_data in fx_traits.items():
            fx_sub = sub.add_parser(name, help=trait_data['desc'])
            add_traits_to_argparse(trait_data['traits'], fx_sub)

        # and a "list" subcommand (same as --list)
        sub.add_parser('list')

        # parse what the main parser left behind
        args = fxparser.parse_args(self._unparsed)

        if args.fx_cmd is None:
            fxparser.print_help()
            sys.exit(1)

        if args.fx_cmd == 'list' or args.list:
            self._list_fx(fx_traits)
            sys.exit(0)

        # apply the traits to an empty object, which will run
        # the validators on the client
        trait_holder = HasTraits()
        traits = fx_traits[args.fx_cmd]['traits']
        trait_holder.add_traits(**traits)

        # apply the argparse flags to the holder object
        for name in trait_holder.traits().keys():
            if hasattr(args, name):
                value = getattr(args, name)
                if value is not None:
                    setattr(trait_holder, name, getattr(args, name))

        if driver.HasFX(args.fx_cmd):
            if self._activate_fx(args, driver, args.fx_cmd, **trait_holder._trait_values):
                sys.exit(0)

            self.print_err('Failed to activate effect')
            sys.exit(1)

        self.print_err('Unsupported effect: %s\n' % args.fx_cmd)
        fxparser.print_help()
        sys.exit(1)


    def _activate_fx(self, args, driver, fx, **kwargs) -> bool:
        if driver.HasFX(fx):
            return driver.SetFX(fx.lower(), dbus_prepare(kwargs, variant=True)[0])

        else:
            self.print_err('Support for this effect (%s) is not implemented' % args.fx_cmd)
            sys.exit(1)

        return False


    def _led_parser(self, args):
        with self.get_driver() as driver:

            led = driver.get_led(LED.Type[args.led_type.upper()])
            if led is None:
                sys.exit(1)

            if args.info:
                led_type = None
                if led.led_type is not None:
                    led_type = led.led_type.name

                mode = None
                if led.mode is not None:
                    mode = led.mode.name

                print('type=%s,state=%s,color=%s,mode=%s,brightness=%f' \
                      % (led_type, led.state, repr(led.color), mode, led.brightness))

            else:
                if args.state is not None:
                    led.state = args.state

                if args.mode is not None:
                    led.mode = LED.Mode[args.mode.upper()]

                if args.color is not None:
                    led.color = args.color.lower()

                if args.brightness is not None:
                    if args.brightness < 0 or args.brightness > 100:
                        self.print_err("Brightness value must be between 0 and 100")
                        sys.exit(1)

                    led.brightness = args.brightness



    @staticmethod
    def ellipsize(line: str, length: int=80):
        if not isinstance(line, str):
            line = repr(line)

        if len(line) < length:
            return line
        return '%s(...)' % line[:length]


    def _dump_parser(self, args):
        driver = self.get_driver()
        result = driver.GetAll('org.chemlab.UChroma.Device')
        keylen = max_keylen(result)
        props = sorted(OrderedDict(result).items())

        layerargs = []
        if hasattr(driver, 'CurrentRenderers'):
            num_renderers = len(driver.CurrentRenderers)
            if num_renderers > 0:
                for layer_idx in range(0, num_renderers):
                    layer = self._client.get_layer(driver, layer_idx)
                    layerargs.append(ArgsDict(sorted( \
                        layer.GetAll('org.chemlab.UChroma.Layer').items())))
                    keylen = max(keylen, max_keylen(layerargs))


        print('\nDevice properties:\n')
        for k, v in props:
            if not args.wide:
                v = UChromaTool.ellipsize(v)
            print(' %*s |  %s' % (keylen, k, v))

        if len(layerargs) > 0:
            print('\n\nAnimation renderer state:\n')
            for layer in layerargs:
                print(' %*s |  %s' % \
                    (keylen, ('Layer %d' % int(layer.get('Zorder'))), layer.get('Key')))
                print(' %s' % ('-' * (keylen + 80)))

                for k, v in layer.items():
                    if k not in ('Zorder', 'Key'):
                        print(' %*s |  %s' % (keylen, k, v))

                print('\n')

        sys.exit(0)


    def _brightness_parser(self, args):
        driver = self.get_driver()
        if not hasattr(driver, 'Brightness'):
            self.print_err('This device does not support brightness control.')
            sys.exit(1)

        if args.level is None:
            print('%f' % driver.Brightness)

        else:
            if args.level < 0 or args.level > 100:
                self.print_err('Brightness must be between 0 and 100')
                sys.exit(1)

            driver.Brightness = args.level


    def _list_anims(self, driver):
        avail = driver.AvailableRenderers

        if avail is None or len(avail) == 0:
            self.print_err('No renderers found.')
            sys.exit(1)

        avail = OrderedDict(sorted(avail.items(), key=lambda k_v: k_v[1]['meta']['display_name']))
        keylen = max_keylen([v['meta']['display_name'] for k, v in avail.items()])

        print('\nAvailable renderers and arguments:\n')

        for v in avail.values():
            meta = v.pop('meta')
            traits = dict_as_class_traits(v)
            print('%*s : %s' % (keylen, meta['display_name'], meta['description']))
            self._show_traits(traits, indent=keylen + 1)
            print('\n')


    def _get_anim_args(self, argspec, variant=False):
        # format is "anim.class.name:key=value,key=value,key=value"
        tokens = argspec.split(':')
        argsdict = OrderedDict()
        layer = tokens[0]

        if len(tokens) == 2:
            pairs = tokens[1].split(',')
            for pair in pairs:
                kv = pair.split('=')
                if len(kv) == 2:
                    argsdict[kv[0]] = kv[1]

        #if variant:
        #    argsdict = VariantDict(argsdict)

        return layer, argsdict


    def _anim_parser(self, args):
        driver = self.get_driver()
        if not driver.HasMatrix:
            self.print_err('This device does not support animations.')
            sys.exit(1)

        if args.list:
            self._list_anims(driver)
            sys.exit(0)

        if args.clear:
            driver.StopAnimation()
            if not driver.ClearRenderers():
                self.print_err("Failed to clear animation layers")
                sys.exit(1)

        if args.add is not None and len(args.add) > 0:
            for add in args.add:
                layer, argsdict = self._get_anim_args(add, variant=True)
                obj = driver.AddRenderer(layer, argsdict)
                if obj is None:
                    self.print_err("Failed to create renderer")
                    sys.exit(1)

                print('Created layer: %s' % obj)

        if args.modify is not None and len(args.modify) > 0:
            for modify in args.modify:
                layer, argsdict = self._get_anim_args(modify)
                layer_obj = self._client.get_layer(driver, int(layer))
                for k, v in argsdict.items():
                    self.set_property(layer_obj, k, v)
                sys.exit(0)

        if args.start:
            if not driver.StartAnimation():
                self.print_err("Failed to start animation")
                sys.exit(1)

        elif args.stop:
            if not driver.StopAnimation():
                self.print_err("Failed to stop animation")
                sys.exit(1)

        sys.exit(0)



if __name__ == '__main__':
    UChromaTool().run()
