#!/usr/bin/env python3

import argparse
import logging
import sys

from grapefruit import Color
from uchroma import UChromaDeviceManager, Splotch
from uchroma.led import LED

logging.basicConfig(stream=sys.stdout, level=logging.INFO)


def print_err(*args):
    sys.stderr.write(' '.join(map(str, args)) + '\n')


class UChromaTool(object):

    def __init__(self):
        parser = argparse.ArgumentParser()

        devs = parser.add_mutually_exclusive_group()
        devs.add_argument("-d", "--device", type=str,
                          help='HID device to use (/dev/hidrawX)')

        sub = parser.add_subparsers()

        test = sub.add_parser('test', help='Test commands')
        test.add_argument('path', metavar='Device path', type=str, help='Test if path is a uChroma device (udev)')
        test.set_defaults(func=self._test_device)

        list_devs = sub.add_parser('list', help='List devices')
        list_devs.set_defaults(func=self._list_devices)

        fx = sub.add_parser('fx', help='Lighting effects')
        action = fx.add_mutually_exclusive_group()
        action.add_argument("--set-brightness", metavar='BRIGHTNESS', type=int, help='Set brightness (0-255)')
        action.add_argument("--get-brightness", action='store_true', help='Get current brightness level')
        action.add_argument("-n", "--disable", action='store_true', help='Disable all effects')
        action.add_argument("-r", "--reactive", action='store_true', help='Enable the reactive keys effect')
        action.add_argument("-s", "--spectrum", action='store_true', help='Cycle colors thru the spectrum')
        action.add_argument("-t", "--static", action='store_true', help='Set a static lighting color')
        action.add_argument("-w", "--wave", action='store_true', help='Waves of color')
        action.add_argument("-b", "--breathe", action='store_true', help='Colors fade in and out in sequence')
        action.add_argument("-i", "--starlight", action='store_true', help='Keys sparkle with color')
        action.add_argument("-o", "--rainbow", action='store_true', help='A rainbow of hues')

        fx.add_argument('-x', '--splotch', type=str, choices=[x.name.lower() for x in Splotch], help='Color pairs (use with breathe and starlight effects)')
        fx.set_defaults(func=self._fx_parser)

        led = sub.add_parser('led', help='LED control')
        led.add_argument('led_type', metavar='LED type', type=str, choices=[x.name.lower() for x in LED.Type], help='Type of LED to control')

        ledx = led.add_mutually_exclusive_group()
        ledx.add_argument('-s', '--state', type=str, choices=[x.name.lower() for x in LED.State], help='State for the LED')
        ledx.add_argument('-m', '--mode', type=str, choices=[x.name.lower() for x in LED.Mode], help='Mode for the LED')
        ledx.add_argument('-c', '--color', type=str, help='RGB color for the LED')
        ledx.add_argument('-b', '--brightness', metavar='BRIGHTNESS', type=int, help='Set brightness (0-255)')
        ledx.add_argument('-i', '--info', action='store_true', help='Get status of LED')
        led.set_defaults(func=self._led_parser)
        self._args = parser.parse_args()

        if not hasattr(self._args, 'func'):
            parser.print_help()
            sys.exit(1)

        self._driver = None
        self._dm = None


    def _get_driver(self):
        if self._args.device is not None:
            if self._args.device not in self._dm.devices:
                sys.exit(1)

            self._driver = self._dm.devices[self._args.device]

        elif len(self._dm.devices) == 1:
            self._driver = self._dm.devices[list(self._dm.devices.keys())[0]]
        else:
            print_err("Multiple devices found, select one with --device")
            sys.exit(1)


    def run(self):
        self._dm = UChromaDeviceManager()

        self._args.func(self._args)


    def finish(self):
        if self._driver is not None:
            self._driver.close()


    def _list_devices(self, args):
        for key in self._dm.devices:
            if self._args.device is None or self._args.device == key:
                d = self._dm.devices[key]
                print('%s: [%04x] %s' % (key, d.product_id, d.name))
        sys.exit(0)


    def _get_splotch(self, args):
        if args.splotch is None:
            return None
        return Splotch[args.splotch.upper()]



    def _test_device(self, args):
        if args.path.startswith('/dev/hidraw'):
            if args.path not in self._dm.devices:
                sys.exit(1)
        elif args.path.startswith('/dev/bus/usb'):
            found = False
            ids = args.path.split('/')
            match = '%04x:%04x:' % (int(ids[-2]), int(ids[-1]))
            for key in self._dm.devices:
                if key.startswith(match):
                    found = True
                    break

            if not found:
                sys.exit(1)

            print('UCHROMA_DEVICE=1')
            sys.exit(0)


    def _fx_parser(self, args):
        self._get_driver()

        if args.set_brightness is not None:
            if args.set_brightness < 0 or args.set_brightness > 255:
                print_err('Brightness must be between 0 and 255')
                sys.exit(1)

            self._driver.brightness = args.set_brightness

        elif args.get_brightness:
            print('%d' % self._driver.brightness)

        if args.breathe:
            if not self._driver.breathe(splotch=self._get_splotch(args)):
                sys.exit(1)

        elif args.disable:
            if not self._driver.disable():
                sys.exit(1)

        elif args.starlight:
            if not self._driver.starlight(splotch=self._get_splotch(args)):
                sys.exit(1)

        elif args.reactive:
            if not self._driver.reactive():
                sys.exit(1)

        elif args.spectrum:
            if not self._driver.spectrum():
                sys.exit(1)

        elif args.static:
            if not self._driver.static_color():
                sys.exit(1)

        elif args.wave:
            if not self._driver.wave():
                sys.exit(1)

        elif args.rainbow:
            if not self._driver.rainbow():
                sys.exit(1)


    def _led_parser(self, args):
        self._get_driver()

        led = self._driver.get_led(LED.Type[args.led_type.upper()])
        if led is None:
            sys.exit(1)

        if args.info:
            led_type = None
            if led.led_type is not None:
                led_type = led.led_type.name

            state = None
            if led.state is not None:
                print(led.state)
                state = led.state.name

            mode = None
            if led.mode is not None:
                mode = led.mode.name

            print('type=%s,state=%s,color=%s,mode=%s,brightness=%d' % (led_type, state, repr(led.color), mode, led.brightness))

        elif args.state:
            led.state = LED.State[args.state.upper()]

        elif args.mode:
            led.mode = LED.Mode[args.mode.upper()]

        elif args.color:
            led.color = Color.NewFromHtml(args.color.lower())

        elif args.brightness:
            if args.brightness < 0 or args.brightness > 255:
                print_err("Brightness value must be between 0 and 255")
                exit(1)

            led.brightness = args.brightness


tool = UChromaTool()
try:
    tool.run()
finally:
    tool.finish()

