#!/usr/bin/env python3

import logging
import re
import sys

from collections import OrderedDict

from traitlets import Undefined

from uchroma import __version__
from uchroma.blending import BlendOp
from uchroma.cmd import UChromaConsoleUtil
from uchroma.color import ColorPair
from uchroma.dbus_utils import VariantDict
from uchroma.led import LED
from uchroma.traits import dict_as_class_traits
from uchroma.util import ArgsDict, max_keylen


logging.basicConfig(stream=sys.stdout, level=logging.INFO)


class UChromaTool(UChromaConsoleUtil):


    def _add_subparsers(self, sub):
        self._brightness_sub = self._add_brightness_options(sub)
        self._anim_sub = self._add_anim_options(sub)
        self._fx_sub = self._add_fx_options(sub)
        self._led_sub = self._add_led_options(sub)
        self._dump_sub = self._add_dump_options(sub)


    def _add_dump_options(self, sub):
        dump = sub.add_parser('dump', help='Dump device info')
        dump.add_argument("-d", "--device", type=str,
                          help='HID device to use (/dev/hidrawX or USB identifier)')
        dump.set_defaults(func=self._dump_parser)
        return dump


    def _add_fx_options(self, sub):
        fx = sub.add_parser('fx', help='Lighting effects')
        fx.add_argument("-d", "--device", type=str,
                        help='HID device to use (/dev/hidrawX or USB identifier)')
        fx.add_argument('--list', action='store_true',
                        help='List supported effects')
        fx.add_argument('fxtype', metavar='EFFECT TYPE', type=str, nargs='?',
                        help='Effect type to activate')

        custom_group = fx.add_argument_group('Effect customization options')
        custom_group.add_argument('-s', '--speed', type=int, help='Effect speed')

        color = custom_group.add_mutually_exclusive_group()
        color.add_argument('-x', '--preset', type=str,
                           choices=[x.name.lower() for x in ColorPair],
                           help='Predefined color pairs')
        color.add_argument('-c', '--color', type=str, action='append',
                           help='Color name or hexcode')
        color.add_argument('-z', '--size', type=int,
                           help='Size parameter for some effects')

        fx.set_defaults(func=self._fx_parser)
        return fx


    def _add_brightness_options(self, sub):
        bright = sub.add_parser('brightness', help='Set/get brightness level')
        bright.add_argument("-d", "--device", type=str,
                            help='HID device to use (/dev/hidrawX or USB identifier)')

        bright.add_argument('level', metavar='BRIGHTNESS', type=float, nargs='?',
                            help='Brightness level to set (0-100)')

        bright.set_defaults(func=self._brightness_parser)
        return bright


    def _add_led_options(self, sub):
        # FIXME: Per-device LEDs
        led = sub.add_parser('led', help='LED control')
        led.add_argument("-d", "--device", type=str,
                         help='HID device to use (/dev/hidrawX or USB identifier)')

        led.add_argument('led_type', metavar='LED type', type=str,
                         choices=[x.name.lower() for x in LED.Type],
                         help='Type of LED to control')
        led.add_argument('-i', '--info', action='store_true', help='Get status of LED')

        ledx = led.add_argument_group('LED attributes')
        ledx.add_argument('-s', '--state', type=bool,
                          help='State for the LED')
        ledx.add_argument('-m', '--mode', type=str,
                          choices=[x.name.lower() for x in LED.Mode],
                          help='Mode for the LED')
        ledx.add_argument('-c', '--color', type=str,
                          help='RGB color for the LED')
        ledx.add_argument('-b', '--brightness', metavar='BRIGHTNESS', type=float,
                          help='Set brightness (0-100)')
        led.set_defaults(func=self._led_parser)
        return led


    def _add_anim_options(self, sub):
        anim = sub.add_parser('anim', help='Animation control')
        anim.add_argument("-d", "--device", type=str,
                          help='HID device to use (/dev/hidrawX or USB identifier)')
        anim.add_argument('--list', action='store_true',
                          help='List available renderers')
        anim.add_argument('-a', '--add', type=str, action='append',
                          help='Adds a new animation layer')
        anim.add_argument('-s', '--start', action='store_true',
                          help='Starts animation with the configured layers')
        anim.add_argument('-q', '--stop', action='store_true',
                          help='Stops the currently running animation')
        anim.add_argument('-c', '--clear', action='store_true',
                          help='Clear the current animation settings')
        anim.add_argument('-m', '--modify', type=str, action='append',
                          help='Modify an existing animation layer')
        anim.add_argument('-b', '--blend', type=str,
                          choices=BlendOp.get_modes(),
                          help='Default blending mode (multiple layers only)')
        anim.set_defaults(func=self._anim_parser)
        return anim


    @staticmethod
    def _get_preset(args):
        if args.preset is None:
            return None
        return ColorPair[args.preset.upper()].name.lower()


    @staticmethod
    def _get_color(args, num):
        if args.color is None:
            return None

        if len(args.color) <= num:
            return None

        return args.color[num]


    def _show_traits(self, traits, indent=0):
        s_traits = sorted(OrderedDict(traits).items())

        for name, trait in s_traits:
            if name in ('description', 'hidden', 'background_color', 'blend_mode', 'opacity'):
                continue

            if trait.read_only or (hasattr(trait, 'write_once') and trait.write_once):
                continue

            trait_type = re.sub(r'Trait$', '', trait.__class__.__name__).lower()
            desc = 'No description available'

            if trait_type == 'caselessstrenum':
                trait_type = 'choice'
                desc = 'one of: %s' % ', '.join([x.lower() for x in sorted(trait.values)])
            elif hasattr(trait, 'info_text'):
                desc = trait.info_text


            constraints = []
            if hasattr(trait, 'min'):
                constraints.append('min: %s' % trait.min)
            if hasattr(trait, 'max'):
                constraints.append('max: %s' % trait.max)
            if hasattr(trait, '_minlen') and trait._minlen > 0:
                constraints.append('min length: %s' % trait._minlen)
            if hasattr(trait, '_maxlen') and trait._maxlen != sys.maxsize:
                constraints.append('max length: %s' % trait._maxlen)
            if hasattr(trait, 'default_value') and trait.default_value is not Undefined:
                constraints.append('default: %s' % trait.default_value)

            if len(constraints) > 0:
                constraints = '[' + (', '.join(constraints)) + ']'
            else:
                constraints = ''

            print('%*s| "%s" (%s): %s %s' % (indent, '', name, trait_type, desc, constraints))


    def _list_fx(self, driver):
        sfx = driver.AvailableFX
        if sfx is None or len(sfx) == 0:
            self.print_err('No supported effects found.')
            sys.exit(1)

        print('\nBuilt-in effects and arguments:\n')
        keylen = max_keylen(sfx)

        for name, t_dict in sorted(sfx.items()):
            traits = dict_as_class_traits(t_dict)
            if 'hidden' in traits:
                if traits['hidden'].default_value:
                    continue
            desc = "No description available"
            if 'description' in traits:
                desc = traits['description'].default_value

            print('[ %*s]: %s' % (keylen, name, desc))
            self._show_traits(traits, indent=keylen + 3)
            print('\n')


    def _fx_parser(self, args):
        driver = self.get_driver(args)
        if args.list or args.fxtype == 'list':
            self._list_fx(driver)
            sys.exit(0)

        if args.fxtype is None:
            self._fx_sub.print_help()
            self._list_fx(driver)
            sys.exit(1)

        if driver.HasFX(args.fxtype):
            if self._activate_fx(driver, args.fxtype):
                sys.exit(0)

            self.print_err('Failed to activate effect')
            sys.exit(1)

        self.print_err('Unsupported effect: %s\n' % args.fxtype)
        self._list_fx(driver)
        sys.exit(0)


    def _activate_fx(self, driver, fx, **kwargs) -> bool:
        if driver.HasFX(fx):
            argsdict = ArgsDict(**kwargs)
            return driver.SetFX(fx.lower(), argsdict)

        else:
            self.print_err('Support for this effect (%s) is not implemented' % fx_args.fxtype)
            sys.exit(1)

        return False


    def _led_parser(self, args):
        with self.get_driver(args) as driver:

            led = driver.get_led(LED.Type[args.led_type.upper()])
            if led is None:
                sys.exit(1)

            if args.info:
                led_type = None
                if led.led_type is not None:
                    led_type = led.led_type.name

                mode = None
                if led.mode is not None:
                    mode = led.mode.name

                print('type=%s,state=%s,color=%s,mode=%s,brightness=%f' \
                      % (led_type, led.state, repr(led.color), mode, led.brightness))

            else:
                if args.state is not None:
                    led.state = args.state

                if args.mode is not None:
                    led.mode = LED.Mode[args.mode.upper()]

                if args.color is not None:
                    led.color = args.color.lower()

                if args.brightness is not None:
                    if args.brightness < 0 or args.brightness > 100:
                        self.print_err("Brightness value must be between 0 and 100")
                        sys.exit(1)

                    led.brightness = args.brightness



    def _dump_parser(self, args):
        driver = self.get_driver(args)
        result = driver.GetAll('org.chemlab.UChroma.Device')

        props = sorted(OrderedDict(result).items())
        print('\nDevice properties:\n')
        for k, v in props:
            print('[ %*s]: %s' % (max_keylen(result), k, v))
        sys.exit(0)


    def _brightness_parser(self, args):
        driver = self.get_driver(args)
        if not hasattr(driver, 'Brightness'):
            self.print_err('This device does not support brightness control.')
            sys.exit(1)

        if args.level is None:
            print('%f' % driver.Brightness)

        else:
            if args.level < 0 or args.level > 100:
                self.print_err('Brightness must be between 0 and 100')
                sys.exit(1)

            driver.Brightness = args.level


    def _list_anims(self, driver):
        avail = driver.AvailableRenderers

        if avail is None or len(avail) == 0:
            self.print_err('No renderers found.')
            sys.exit(1)

        avail = OrderedDict(sorted(avail.items(), key=lambda k_v: k_v[1]['meta']['display_name']))
        keylen = max_keylen([v['meta']['display_name'] for k, v in avail.items()])

        print('\nAvailable renderers and arguments:\n')

        for v in avail.values():
            meta = v.pop('meta')
            traits = dict_as_class_traits(v)
            print('[ %*s]: %s' % (keylen, meta['display_name'], meta['description']))
            self._show_traits(traits, indent=keylen + 3)
            print('\n')


    def _get_anim_args(self, argspec, variant=False):
        # format is "anim.class.name:key=value,key=value,key=value"
        tokens = argspec.split(':')
        argsdict = OrderedDict()
        layer = tokens[0]

        if len(tokens) == 2:
            pairs = tokens[1].split(',')
            for pair in pairs:
                kv = pair.split('=')
                if len(kv) == 2:
                    argsdict[kv[0]] = kv[1]

        if variant:
            argsdict = VariantDict(argsdict)

        return layer, argsdict


    def _anim_parser(self, args):
        driver = self.get_driver(args)
        if not driver.HasMatrix:
            self.print_err('This device does not support animations.')
            sys.exit(1)

        if args.list:
            self._list_anims(driver)
            sys.exit(0)

        if args.clear:
            driver.StopAnimation()
            if not driver.ClearRenderers():
                self.print_err("Failed to clear animation layers")
                sys.exit(1)

        if args.add is not None and len(args.add) > 0:
            for add in args.add:
                layer, argsdict = self._get_anim_args(add, variant=True)
                obj = driver.AddRenderer(layer, argsdict)
                if obj is None:
                    self.print_err("Failed to create renderer")
                    sys.exit(1)

                print('Created layer: %s' % obj)

        if args.modify is not None and len(args.modify) > 0:
            for modify in args.modify:
                layer, argsdict = self._get_anim_args(modify)
                layer_obj = self._client.get_layer(driver, int(layer))
                for k, v in argsdict.items():
                    self.set_property(layer_obj, k, v)
                sys.exit(0)

        if args.start:
            if not driver.StartAnimation():
                self.print_err("Failed to start animation")
                sys.exit(1)

        elif args.stop:
            if not driver.StopAnimation():
                self.print_err("Failed to stop animation")
                sys.exit(1)

        sys.exit(0)



if __name__ == '__main__':
    UChromaTool().run()
