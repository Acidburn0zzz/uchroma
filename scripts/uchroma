#!/usr/bin/env python3
# pylint: disable=protected-access, invalid-name
import re
import sys

from abc import abstractmethod
from argparse import ArgumentParser
from collections import OrderedDict
from typing import NamedTuple

from traitlets import Undefined

from uchroma import __version__
from uchroma.cmd import UChromaConsoleUtil
from uchroma.color import ColorPair
from uchroma.dbus_utils import dbus_prepare
from uchroma.traits import add_traits_to_argparse, apply_from_argparse, dict_as_class_traits
from uchroma.util import ArgsDict, max_keylen


RemoteTraits = NamedTuple('RemoteTraits', [('name', str),
                                           ('description', str),
                                           ('traits', dict)])

def ellipsize(line: str, length: int=80):
    if not isinstance(line, str):
        line = repr(line)

    if len(line) < length:
        return line
    return '%s(...)' % line[:length]


class AbstractCommand(object):
    def __init__(self, parent):
        self._parent = parent


    @property
    def driver(self):
        return self._parent.get_driver()


    @property
    def client(self):
        return self._parent._client


    @property
    def unparsed_args(self):
        return self._parent._unparsed


    @property
    def parent_parser(self):
        return self._parent._parser


    def exit(self, status=0, message=None):
        self._parent._parser.exit(status, message)


    def error(self, message):
        self._parent.error(message)


    def set_property(self, target, name, value):
        self._parent.set_property(target, name, value)


    @staticmethod
    def get_preset(args):
        if args.preset is None:
            return None
        return ColorPair[args.preset.upper()].name.lower()


    @staticmethod
    def get_color(args, num):
        if args.color is None:
            return None

        if len(args.color) <= num:
            return None

        return args.color[num]


    @classmethod
    def show_traits(cls, traits, indent=0):
        s_traits = sorted(OrderedDict(traits).items())
        for name, trait in s_traits:
            if name in ('description', 'hidden', 'background_color', 'blend_mode', 'opacity'):
                continue

            if trait.read_only or (hasattr(trait, 'write_once') and trait.write_once):
                continue

            trait_type = re.sub(r'Trait$', '', trait.__class__.__name__).lower()
            desc = 'No description available'

            if trait_type == 'caselessstrenum':
                trait_type = 'choice'
                desc = 'one of: %s' % ', '.join([x.lower() for x in sorted(trait.values)])
            elif hasattr(trait, 'info_text'):
                desc = trait.info_text

            constraints = []
            if hasattr(trait, 'min'):
                constraints.append('min: %s' % trait.min)
            if hasattr(trait, 'max'):
                constraints.append('max: %s' % trait.max)
            if hasattr(trait, '_minlen') and trait._minlen > 0:
                constraints.append('min length: %s' % trait._minlen)
            if hasattr(trait, '_maxlen') and trait._maxlen != sys.maxsize:
                constraints.append('max length: %s' % trait._maxlen)
            if hasattr(trait, 'default_value') and trait.default_value is not Undefined:
                constraints.append('default: %s' % trait.default_value)

            constraint_str = ''
            if len(constraints) > 0:
                constraint_str = '[' + (', '.join(constraints)) + ']'

            print('%*s| "%s" (%s): %s %s' % (indent, '', name, trait_type, desc, constraint_str))


    @classmethod
    def list_objects(cls, objects, aliases=None):
        if aliases is None:
            keys = objects.keys()
        else:
            keys = [aliases.get(k, k) for k in objects.keys()]

        keylen = max_keylen(keys)

        for name, trait_data in objects.items():
            dname = name
            if aliases is not None and name in aliases:
                dname = aliases[name]

            print(' %*s | %s' % (keylen, dname, trait_data.description))
            cls.show_traits(trait_data.traits, indent=keylen + 2)
            print('\n')


    @abstractmethod
    def add_parser(self, parser):
        pass


    @abstractmethod
    def parse(self, args):
        pass


class DumpCommand(AbstractCommand):
    def add_parser(self, sub):
        dump = sub.add_parser('dump', help='Dump device info')
        dump.add_argument("-w", "--wide", action="store_true",
                          help="Wide output (don't truncate long lines")
        dump.set_defaults(func=self.parse)
        return dump


    def parse(self, args):
        result = self.driver.GetAll('org.chemlab.UChroma.Device')
        keylen = max_keylen(result)
        props = sorted(OrderedDict(result).items())

        layerargs = []
        if hasattr(self.driver, 'CurrentRenderers'):
            num_renderers = len(self.driver.CurrentRenderers)
            if num_renderers > 0:
                for layer_idx in range(0, num_renderers):
                    layer = self.client.get_layer(self.driver, layer_idx)
                    layerargs.append(ArgsDict(sorted( \
                        layer.GetAll('org.chemlab.UChroma.Layer').items())))
                    keylen = max(keylen, max_keylen(layerargs))


        print('\nDevice properties:\n')
        for k, v in props:
            if not args.wide:
                v = ellipsize(v)
            print(' %*s |  %s' % (keylen, k, v))

        if len(layerargs) > 0:
            print('\n\nAnimation renderer state:\n')
            for layer in layerargs:
                print(' %*s |  %s' % \
                    (keylen, ('Layer %d' % int(layer.get('Zorder'))), layer.get('Key')))
                print(' %s' % ('-' * (keylen + 80)))

                for k, v in layer.items():
                    if k not in ('Zorder', 'Key'):
                        print(' %*s |  %s' % (keylen, k, v))

                print('\n')


class BrightnessCommand(AbstractCommand):
    def __init__(self, *args, **kwargs):
        super(BrightnessCommand, self).__init__(*args, **kwargs)
        self._sub = None

    def add_parser(self, sub):
        self._sub = sub.add_parser('brightness', help='Set/get brightness level')
        self._sub.add_argument('level', metavar='BRIGHTNESS', type=float, nargs='?',
                               help='Brightness level to set (0-100)')

        self._sub.set_defaults(func=self.parse)
        return self._sub


    def parse(self, args):
        if not hasattr(self.driver, 'Brightness'):
            self._sub.error('This device does not support brightness control.')

        if args.level is None:
            print('%f' % self.driver.Brightness)

        else:
            if args.level < 0 or args.level > 100:
                self._sub.error('Brightness must be between 0 and 100')

            self.driver.Brightness = args.level


class LEDCommand(AbstractCommand):
    def __init__(self, *args, **kwargs):
        super(LEDCommand, self).__init__(*args, **kwargs)
        self._leds = None
        self._sub = None
        self._parsers = {}

    def add_parser(self, sub):
        # argparse trickery!
        # since you can't chain subparsers, we create a base subparser off the
        # root, then create new parsers in the callback with the parent
        # set back to us. "parse_known_args" is needed to make this work.
        self._sub = sub.add_parser('led', help='LED control', add_help=False)
        self._sub.add_argument('-l', '--list', action='store_true',
                               help="Show available LEDs")
        self._sub.set_defaults(func=self.parse)
        return self._sub


    @property
    def available_leds(self):
        if self._leds is not None:
            return self._leds

        self._leds = OrderedDict()
        for name, t_dict in sorted(self.driver.AvailableLEDs.items()):
            traits = dict_as_class_traits(t_dict)
            self._leds[name] = RemoteTraits(name.lower(), \
                    "Standalone LED: %s" % name.title(), traits)

        return self._leds


    def _list(self, args):
        if len(self.available_leds) == 0:
            self._sub.error('No supported LEDs found')

        print("\nStandalone LED controls:\n")
        self.list_objects(self.available_leds)


    def parse(self, args):
        if args.list:
            self._list(args)
            sys.exit(0)

        led_parser = ArgumentParser(description="LED commands",
                                    parents=[self._sub], add_help=False)

        sub = led_parser.add_subparsers(title="Standalone LEDs", dest='led_cmd')

        sub.add_parser('list').set_defaults(func_led=self._list)

        # fill in args using traits
        for name, trait_data in self.available_leds.items():
            led_sub = sub.add_parser(name, help=trait_data.description)
            add_traits_to_argparse(trait_data.traits, led_sub)
            led_sub.set_defaults(func_led=self._led_control)
            self._parsers[name] = led_sub

        led_args = led_parser.parse_args(self.unparsed_args)

        if not hasattr(led_args, 'func_led'):
            led_parser.print_help()
            sys.exit(1)

        led_args.func_led(led_args)


    def _led_control(self, args):
        led = args.led_cmd.lower()

        # need at least one argument
        if any([v is not None for k, v in vars(args).items() \
                if k not in ('func', 'func_led', 'list', 'led_cmd')]):
            changed = apply_from_argparse(args, traits=self.available_leds[led].traits)

            if not self.driver.SetLED(led, dbus_prepare(changed, variant=True)[0]):
                self._parsers[led].error("Failed to configure LED")

        else:
            self._parsers[led].print_help()
            self._parsers[led].error("At least one option is required")


class FXCommand(AbstractCommand):
    def __init__(self, *args, **kwargs):
        super(FXCommand, self).__init__(*args, **kwargs)
        self._fx = None
        self._sub = None
        self._parsers = {}

    def add_parser(self, sub):
        self._sub = sub.add_parser('fx', help='Lighting and effects', add_help=False)
        self._sub.add_argument('-l', '--list', action='store_true',
                               help='List supported effects')
        self._sub.set_defaults(func=self.parse)
        return self._sub


    @property
    def available_fx(self):
        if self._fx is not None:
            return self._fx

        self._fx = OrderedDict()
        for name, t_dict in sorted(self.driver.AvailableFX.items()):
            traits = dict_as_class_traits(t_dict)
            if 'hidden' in traits and traits['hidden'].default_value:
                continue

            self._fx[name] = RemoteTraits(name, \
                traits['description'].default_value, traits)

        return self._fx


    def _list(self, args):
        if self.available_fx is None or len(self.available_fx) == 0:
            self._sub.error('No supported effects found.')

        print('\nBuilt-in effects and arguments:\n')
        self.list_objects(self.available_fx)


    def parse(self, args):
        if args.list:
            self._list(args)
            sys.exit(0)

        fx_parser = ArgumentParser(description='FX Commands',
                                   parents=[self._sub])
        sub = fx_parser.add_subparsers(title='Built-in effects', dest='fx_cmd')

        # and a "list" subcommand (same as --list)
        sub.add_parser('list').set_defaults(func_fx=self._list)

        # turn all traits into argparse commands
        for name, trait_data in self.available_fx.items():
            fx_sub = sub.add_parser(name, help=trait_data.description)
            add_traits_to_argparse(trait_data.traits, fx_sub)
            fx_sub.set_defaults(func_fx=self._activate_fx)
            self._parsers[name] = fx_sub

        # parse what the main parser left behind
        fx_args = fx_parser.parse_args(self.unparsed_args)

        if not hasattr(fx_args, 'func_fx'):
            fx_parser.print_help()
            sys.exit(1)

        fx_args.func_fx(fx_args)


    def _activate_fx(self, args):
        fx = args.fx_cmd.lower()

        if self.driver.HasFX(fx):
            # apply the traits to an empty object, which will run
            # the validators on the client
            changed = apply_from_argparse(args, traits=self.available_fx[fx].traits)

            if not self.driver.SetFX(fx, dbus_prepare(changed, variant=True)[0]):
                self._parsers[fx].error("Failed to activate effect")

        else:
            self._parsers[fx].error("Unsupported effect: (%s)" % args.fx_cmd)


class AnimationCommand(AbstractCommand):
    def __init__(self, *args, **kwargs):
        super(AnimationCommand, self).__init__(*args, **kwargs)
        self._renderer_info = None
        self._aliases = {}
        self._anim_args = None
        self._unparsed = None
        self._parsers = {}
        self._anim_parser = None
        self._sub = None

    def add_parser(self, sub):
        self._sub = sub.add_parser('anim', help='Animation control', add_help=False)
        self._sub.add_argument('-l', '--list', action='store_true',
                               help="List available renderers and options")
        self._sub.set_defaults(func=self.parse)
        return self._sub


    def parse(self, args):
        if args.list:
            self._list(args)
            exit(0)

        self._anim_parser = ArgumentParser(description="Animation renderer and layer controls",
                                           parents=[self._sub], add_help=False)

        sub = self._anim_parser.add_subparsers(title='Commands')

        sub.add_parser('list').set_defaults(func_anim=self._list)

        p1 = sub.add_parser('add', help="Add a new renderer", add_help=False)
        p1.add_argument('name', type=str, help="Class name of the renderer")
        p1.add_argument('-p', '--paused', action='store_true',
                        help="Do not immediately start")
        p1.set_defaults(func_anim=self._add)
        self._parsers['add'] = p1

        p2 = sub.add_parser('modify', help="Modify an existing layer", add_help=False)
        p2.add_argument('layer', type=int, help="Layer index to modify")
        p2.set_defaults(func_anim=self._modify)
        self._parsers['modify'] = p2

        self._parsers['start'] = sub.add_parser('start', help="Start a paused animation") \
                .set_defaults(func_anim=self._start)
        self._parsers['stop'] = sub.add_parser('stop', help="Stop the running animation") \
                .set_defaults(func_anim=self._stop)
        self._parsers['pause'] = sub.add_parser('pause', help="Pause the animation") \
                .set_defaults(func_anim=self._pause)

        anim_args, self._unparsed = self._anim_parser.parse_known_args(self.unparsed_args)

        if not hasattr(anim_args, 'func_anim'):
            self._anim_parser.print_help()
            sys.exit(1)

        anim_args.func_anim(anim_args)


    @property
    def renderer_info(self):
        if self._renderer_info is not None:
            return self._renderer_info

        avail = self.driver.AvailableRenderers
        if avail is None or len(avail) == 0:
            self._anim_parser.error("No renderers available.")

        sar = OrderedDict(sorted(avail.items(),
                                 key=lambda k_v: k_v[1]['meta']['display_name']))
        exploded = OrderedDict()
        for name, t_anim in sar.items():
            rt = RemoteTraits(t_anim['meta']['display_name'],
                              t_anim['meta']['description'],
                              dict_as_class_traits(t_anim['traits']))
            exploded[name] = rt
            self._aliases[rt.name.replace(' ', '_').lower()] = name

        self._renderer_info = exploded
        return self._renderer_info


    def _list(self, args):
        print('\nAvailable renderers and arguments:\n')
        self.list_objects(self.renderer_info,
                          aliases={v: k for k, v in self._aliases.items()})


    def _pause(self, args):
        if not self.driver.StopAnimation():
            self._parsers['pause'].error("Failed to stop animation")


    def _stop(self, args):
        self._pause(args)
        if not self.driver.ClearRenderers():
            self._parsers['stop'].error("Failed to clear animation layers")


    def _start(self, args):
        if not self.driver.StartAnimation():
            self._parsers['start'].error("Failed to start animation")


    def _parse_traits(self, req_anim, parent, required: bool=False) -> dict:
        parser = ArgumentParser(description=req_anim.description,
                                parents=[parent])

        add_traits_to_argparse(req_anim.traits, parser)
        args = parser.parse_args(self._unparsed)
        changed = apply_from_argparse(args, traits=req_anim.traits)

        if required and len(changed) == 0:
            parser.print_help()
            parser.error("At least one option must be selected to modify")

        return changed


    def _add(self, args):
        parser = self._parsers['add']

        rname = args.name
        if rname not in self.renderer_info and rname not in self._aliases:
            self._list(args)
            parser.error("%s is not a valid renderer" % (rname))

        if rname not in self.renderer_info:
            rname = self._aliases[rname]

        req_anim = self.renderer_info[rname]
        traits = self._parse_traits(req_anim, parser)

        layer = self.driver.AddRenderer(rname, dbus_prepare(traits, variant=True)[0])
        if layer is None:
            parser.error("Failed to create renderer")

        print('Created layer: %s' % layer)
        if not args.paused:
            if not self.driver.StartAnimation():
                parser.error("Failed to start animation")


    def _modify(self, args):
        parser = self._parsers['modify']

        layers = self.driver.CurrentRenderers
        if args.layer >= len(layers):
            self._list(args)
            parser.error("Layer index out of range")

        req_anim = self.renderer_info[layers[args.layer][0]]
        traits = self._parse_traits(req_anim, parser, required=True)
        layer_obj = self.client.get_layer(self.driver, args.layer)

        # Renderers expose their properties via dbus while running
        for k, v in traits.items():
            self.set_property(layer_obj, k, v)


class UChromaTool(UChromaConsoleUtil):

    COMMANDS = [DumpCommand, BrightnessCommand, LEDCommand, FXCommand, AnimationCommand]

    def _add_subparsers(self, sub):
        for command in UChromaTool.COMMANDS:
            cmd = command(self)
            cmd.add_parser(sub)



if __name__ == '__main__':
    UChromaTool().run()
