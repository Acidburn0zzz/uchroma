#!/usr/bin/env python3

import argparse
import logging
import sys

from uchroma import __version__
from uchroma.color import Splotch
from uchroma.device_manager import UChromaDeviceManager
from uchroma.led import LED
from uchroma.types import FX
from uchroma.util import enumarg, EnumType


logging.basicConfig(stream=sys.stdout, level=logging.INFO)


def print_err(*args):
    sys.stderr.write(' '.join(map(str, args)) + '\n')


class UChromaTool(object):

    def __init__(self):
        parser = argparse.ArgumentParser(
            description='Color control for Razer Chroma peripherals')

        parser.add_argument("-v", "--version", action='version', version='uChroma-%s' % __version__)
        parser.add_argument("--debug", action='store_true', help='Enable debug output')

        sub = parser.add_subparsers(title='Subcommands')

        list_devs = sub.add_parser('list', help='List devices')
        list_devs.set_defaults(func=self._list_devices)

        self._brightness_sub = self._add_brightness_options(sub)
        self._fx_sub = self._add_fx_options(sub)
        self._led_sub = self._add_led_options(sub)

        test = sub.add_parser('test', help='Test commands')
        test.add_argument('path', metavar='Device path', type=str,
                          help='Test if path is a uChroma device (udev)')
        test.set_defaults(func=self._test_device)

        self._args = parser.parse_args()

        if self._args.debug:
            logging.getLogger().setLevel(logging.DEBUG)

        if not hasattr(self._args, 'func'):
            parser.print_help()
            sys.exit(1)

        self._parser = parser
        self._dm = UChromaDeviceManager()


    def _add_fx_options(self, sub):
        fx = sub.add_parser('fx', help='Lighting effects')
        fx.add_argument("-d", "--device", type=str,
                        help='HID device to use (/dev/hidrawX or USB identifier)')
        fx.add_argument('--list', action='store_true',
                        help='List supported effects')
        fx.add_argument('fxtype', metavar='EFFECT TYPE', type=str, nargs='?',
                        help='Effect type to activate')

        custom_group = fx.add_argument_group('Effect customization options')
        custom_group.add_argument('-s', '--speed', type=int, help='Effect speed')

        color = custom_group.add_mutually_exclusive_group()
        color.add_argument('-x', '--splotch', type=str,
                           choices=[x.name.lower() for x in Splotch],
                           help='Predefined color pairs')
        color.add_argument('-c', '--color', type=str, action='append',
                           help='Color name or hexcode')
        color.add_argument('-z', '--size', type=int,
                           help='Size parameter for some effects')

        fx.set_defaults(func=self._fx_parser)
        return fx


    def _add_brightness_options(self, sub):
        bright = sub.add_parser('brightness', help='Set/get brightness level')
        bright.add_argument("-d", "--device", type=str,
                            help='HID device to use (/dev/hidrawX or USB identifier)')

        bright.add_argument('level', metavar='BRIGHTNESS', type=float, nargs='?',
                            help='Brightness level to set (0-100)')

        bright.set_defaults(func=self._brightness_parser)
        return bright


    def _add_led_options(self, sub):
        # FIXME: Per-device LEDs
        led = sub.add_parser('led', help='LED control')
        led.add_argument("-d", "--device", type=str,
                         help='HID device to use (/dev/hidrawX or USB identifier)')

        led.add_argument('led_type', metavar='LED type', type=str,
                         choices=[x.name.lower() for x in LED.Type],
                         help='Type of LED to control')
        led.add_argument('-i', '--info', action='store_true', help='Get status of LED')

        ledx = led.add_argument_group('LED attributes')
        ledx.add_argument('-s', '--state', type=bool,
                          help='State for the LED')
        ledx.add_argument('-m', '--mode', type=str,
                          choices=[x.name.lower() for x in LED.Mode],
                          help='Mode for the LED')
        ledx.add_argument('-c', '--color', type=str,
                          help='RGB color for the LED')
        ledx.add_argument('-b', '--brightness', metavar='BRIGHTNESS', type=float,
                          help='Set brightness (0-100)')
        led.set_defaults(func=self._led_parser)
        return led


    def _get_driver(self, args):
        driver = None

        if args.device is not None:
            if args.device not in self._dm.devices:
                sys.exit(1)

            driver = self._dm.devices[args.device]

        elif len(self._dm.devices) == 1:
            driver = self._dm.devices[list(self._dm.devices.keys())[0]]
        else:
            print_err("Multiple devices found, select one with --device")
            sys.exit(1)

        driver.defer_close = False

        return driver


    def run(self):
        self._args.func(self._args)


    def _list_devices(self, args):
        for key in self._dm.devices:
            d = self._dm.devices[key]
            print('[%s]: %s (%s / %s)' % (key, d.name, d.serial_number, d.firmware_version))
        sys.exit(0)


    @staticmethod
    def _get_splotch(args):
        if args.splotch is None:
            return None
        return Splotch[args.splotch.upper()]


    @staticmethod
    def _get_color(args, num):
        if args.color is None:
            return None

        if len(args.color) <= num:
            return None

        return args.color[num]


    def _test_device(self, args):
        if args.path.startswith('/dev/hidraw'):
            if args.path not in self._dm.devices:
                sys.exit(1)
        elif args.path.startswith('/dev/bus/usb'):
            found = False
            ids = args.path.split('/')
            match = '%04x:%04x:' % (int(ids[-2]), int(ids[-1]))
            for key in self._dm.devices:
                if key.startswith(match):
                    found = True
                    break

            if not found:
                sys.exit(1)

            print('UCHROMA_DEVICE=1')
            sys.exit(0)


    def _list_fx(self, driver):
        if driver.supported_fx is None:
            print_err('No supported effects found.')
            sys.exit(1)

        print('\nSupported effects:\n')
        for fx in sorted(driver.supported_fx):
            print('%20s     %s' % (fx.name.lower(), fx.description))


    def _fx_parser(self, args):
        driver = self._get_driver(args)

        if args.list or args.fxtype == 'list':
            self._list_fx(driver)
            sys.exit(0)

        if args.fxtype is None:
            self._fx_sub.print_help()
            self._list_fx(driver)
            sys.exit(1)

        if driver.has_fx(args.fxtype):
            if self._activate_fx(args.fxtype, args, driver):
                sys.exit(0)

            print_err('Failed to activate effect')
            sys.exit(1)

        print_err('Unsupported effect: %s\n' % args.fxtype)
        self._list_fx(driver)
        sys.exit(0)



    @enumarg(FX)
    def _activate_fx(self, fx: EnumType, fx_args, driver) -> bool:

        if fx == FX.BREATHE:
            return driver.breathe(color1=UChromaTool._get_color(fx_args, 0),
                                  color2=UChromaTool._get_color(fx_args, 1),
                                  splotch=UChromaTool._get_splotch(fx_args))

        elif fx == FX.DISABLE:
            return driver.disable()

        elif fx == FX.FIRE:
            return driver.fire(color=UChromaTool._get_color(fx_args, 0),
                               speed=fx_args.speed)

        elif fx == FX.MORPH:
            return driver.morph(base_color=UChromaTool._get_color(fx_args, 0),
                                color=UChromaTool._get_color(fx_args, 1),
                                splotch=UChromaTool._get_splotch(fx_args),
                                speed=fx_args.speed)

        elif fx == FX.RAINBOW:
            return driver.rainbow(length=fx_args.size)

        elif fx == FX.REACTIVE:
            return driver.reactive(color=UChromaTool._get_color(fx_args, 0),
                                   speed=fx_args.speed)

        elif fx == FX.RIPPLE:
            return driver.ripple(color=UChromaTool._get_color(fx_args, 0),
                                 speed=fx_args.speed)

        elif fx == FX.RIPPLE_SOLID:
             return driver.ripple_solid(color=UChromaTool._get_color(fx_args, 0),
                                        speed=fx_args.speed)

        elif fx == FX.SPECTRUM:
            return driver.spectrum()

        elif fx == FX.STARLIGHT:
            return driver.starlight(color1=UChromaTool._get_color(fx_args, 0),
                                    color2=UChromaTool._get_color(fx_args, 1),
                                    splotch=UChromaTool._get_splotch(fx_args),
                                    speed=fx_args.speed)

        elif fx == FX.STATIC:
            return driver.static(color=UChromaTool._get_color(fx_args, 0))

        elif fx == FX.SWEEP:
            return driver.sweep(base_color=UChromaTool._get_color(fx_args, 0),
                                color=UChromaTool._get_color(fx_args, 1),
                                splotch=UChromaTool._get_splotch(fx_args),
                                speed=fx_args.speed)

        elif fx == FX.WAVE:
            return driver.wave()

        else:
            print_err('Support for this effect (%s) is not implemented', fx_args.fxtype)
            sys.exit(1)

        return False


    def _led_parser(self, args):
        driver = self._get_driver(args)

        led = driver.get_led(LED.Type[args.led_type.upper()])
        if led is None:
            sys.exit(1)

        if args.info:
            led_type = None
            if led.led_type is not None:
                led_type = led.led_type.name

            mode = None
            if led.mode is not None:
                mode = led.mode.name

            print('type=%s,state=%s,color=%s,mode=%s,brightness=%f' \
                  % (led_type, led.state, repr(led.color), mode, led.brightness))

        else:
            if args.state is not None:
                led.state = args.state

            if args.mode is not None:
                led.mode = LED.Mode[args.mode.upper()]

            if args.color is not None:
                led.color = args.color.lower()

            if args.brightness is not None:
                if args.brightness < 0 or args.brightness > 100:
                    print_err("Brightness value must be between 0 and 100")
                    exit(1)

                led.brightness = args.brightness


    def _brightness_parser(self, args):
        driver = self._get_driver(args)

        if args.level is None:
            print('%f' % driver.brightness)

        else:
            if args.level < 0 or args.level > 100:
                print_err('Brightness must be between 0 and 100')
                sys.exit(1)

            driver.brightness = args.level


tool = UChromaTool()
try:
    tool.run()
finally:
    pass
