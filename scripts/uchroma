#!/usr/bin/env python3
# pylint: disable=protected-access, invalid-name
import re
import sys

from abc import abstractmethod
from argparse import ArgumentParser
from collections import OrderedDict
from typing import NamedTuple

from traitlets import HasTraits, Undefined

from uchroma import __version__
from uchroma.blending import BlendOp
from uchroma.cmd import UChromaConsoleUtil
from uchroma.color import ColorPair
from uchroma.dbus_utils import dbus_prepare
from uchroma.led import LED
from uchroma.renderer import RendererMeta
from uchroma.traits import add_traits_to_argparse, apply_from_argparse, dict_as_class_traits
from uchroma.util import ArgsDict, max_keylen


RemoteTraits = NamedTuple('RemoteTraits', [('name', str),
                                           ('description', str),
                                           ('traits', dict)])

def ellipsize(line: str, length: int=80):
    if not isinstance(line, str):
        line = repr(line)

    if len(line) < length:
        return line
    return '%s(...)' % line[:length]


class AbstractCommand(object):
    def __init__(self, parent):
        self._parent = parent


    @property
    def driver(self):
        return self._parent.get_driver()


    @property
    def client(self):
        return self._parent._client


    @property
    def unparsed_args(self):
        return self._parent._unparsed


    @property
    def parent_parser(self):
        return self._parent._parser


    def exit(self, status=0, message=None):
        self._parent._parser.exit(status, message)


    def error(self, message):
        self._parent.error(message)


    def set_property(self, target, name, value):
        self._parent.set_property(target, name, value)


    @staticmethod
    def get_preset(args):
        if args.preset is None:
            return None
        return ColorPair[args.preset.upper()].name.lower()


    @staticmethod
    def get_color(args, num):
        if args.color is None:
            return None

        if len(args.color) <= num:
            return None

        return args.color[num]


    def show_traits(self, traits, indent=0):
        s_traits = sorted(OrderedDict(traits).items())

        for name, trait in s_traits:
            if name in ('description', 'hidden', 'background_color', 'blend_mode', 'opacity'):
                continue

            if trait.read_only or (hasattr(trait, 'write_once') and trait.write_once):
                continue

            trait_type = re.sub(r'Trait$', '', trait.__class__.__name__).lower()
            desc = 'No description available'

            if trait_type == 'caselessstrenum':
                trait_type = 'choice'
                desc = 'one of: %s' % ', '.join([x.lower() for x in sorted(trait.values)])
            elif hasattr(trait, 'info_text'):
                desc = trait.info_text


            constraints = []
            if hasattr(trait, 'min'):
                constraints.append('min: %s' % trait.min)
            if hasattr(trait, 'max'):
                constraints.append('max: %s' % trait.max)
            if hasattr(trait, '_minlen') and trait._minlen > 0:
                constraints.append('min length: %s' % trait._minlen)
            if hasattr(trait, '_maxlen') and trait._maxlen != sys.maxsize:
                constraints.append('max length: %s' % trait._maxlen)
            if hasattr(trait, 'default_value') and trait.default_value is not Undefined:
                constraints.append('default: %s' % trait.default_value)

            constraint_str = ''
            if len(constraints) > 0:
                constraint_str = '[' + (', '.join(constraints)) + ']'

            print('%*s| "%s" (%s): %s %s' % (indent, '', name, trait_type, desc, constraint_str))


    @abstractmethod
    def add_parser(self, parser):
        pass


    @abstractmethod
    def parse(self, args):
        pass


class DumpCommand(AbstractCommand):
    def add_parser(self, sub):
        dump = sub.add_parser('dump', help='Dump device info')
        dump.add_argument("-w", "--wide", action="store_true",
                          help="Wide output (don't truncate long lines")
        dump.set_defaults(func=self.parse)
        return dump


    def parse(self, args):
        result = self.driver.GetAll('org.chemlab.UChroma.Device')
        keylen = max_keylen(result)
        props = sorted(OrderedDict(result).items())

        layerargs = []
        if hasattr(self.driver, 'CurrentRenderers'):
            num_renderers = len(self.driver.CurrentRenderers)
            if num_renderers > 0:
                for layer_idx in range(0, num_renderers):
                    layer = self.client.get_layer(self.driver, layer_idx)
                    layerargs.append(ArgsDict(sorted( \
                        layer.GetAll('org.chemlab.UChroma.Layer').items())))
                    keylen = max(keylen, max_keylen(layerargs))


        print('\nDevice properties:\n')
        for k, v in props:
            if not args.wide:
                v = ellipsize(v)
            print(' %*s |  %s' % (keylen, k, v))

        if len(layerargs) > 0:
            print('\n\nAnimation renderer state:\n')
            for layer in layerargs:
                print(' %*s |  %s' % \
                    (keylen, ('Layer %d' % int(layer.get('Zorder'))), layer.get('Key')))
                print(' %s' % ('-' * (keylen + 80)))

                for k, v in layer.items():
                    if k not in ('Zorder', 'Key'):
                        print(' %*s |  %s' % (keylen, k, v))

                print('\n')


class BrightnessCommand(AbstractCommand):
    def add_parser(self, sub):
        bright = sub.add_parser('brightness', help='Set/get brightness level')
        bright.add_argument('level', metavar='BRIGHTNESS', type=float, nargs='?',
                            help='Brightness level to set (0-100)')

        bright.set_defaults(func=self.parse)
        return bright


    def parse(self, args):
        if not hasattr(self.driver, 'Brightness'):
            self.error('This device does not support brightness control.')

        if args.level is None:
            print('%f' % self.driver.Brightness)

        else:
            if args.level < 0 or args.level > 100:
                self.error('Brightness must be between 0 and 100')

            self.driver.Brightness = args.level


class LEDCommand(AbstractCommand):
    def add_parser(self, sub):
        # FIXME: Per-device LEDs
        led = sub.add_parser('led', help='LED control')
        led.add_argument('led_type', metavar='LED type', type=str,
                         choices=[x.name.lower() for x in LED.Type],
                         help='Type of LED to control')
        led.add_argument('-i', '--info', action='store_true', help='Get status of LED')

        ledx = led.add_argument_group('LED attributes')
        ledx.add_argument('-s', '--state', type=bool,
                          help='State for the LED')
        ledx.add_argument('-m', '--mode', type=str,
                          choices=[x.name.lower() for x in LED.Mode],
                          help='Mode for the LED')
        ledx.add_argument('-c', '--color', type=str,
                          help='RGB color for the LED')
        ledx.add_argument('-b', '--brightness', metavar='BRIGHTNESS', type=float,
                          help='Set brightness (0-100)')
        led.set_defaults(func=self.parse)
        return led


    def parse(self, args):
        with self.driver as driver:

            led = driver.get_led(LED.Type[args.led_type.upper()])
            if led is None:
                sys.exit(1)

            if args.info:
                led_type = None
                if led.led_type is not None:
                    led_type = led.led_type.name

                mode = None
                if led.mode is not None:
                    mode = led.mode.name

                print('type=%s,state=%s,color=%s,mode=%s,brightness=%f' \
                      % (led_type, led.state, repr(led.color), mode, led.brightness))

            else:
                if args.state is not None:
                    led.state = args.state

                if args.mode is not None:
                    led.mode = LED.Mode[args.mode.upper()]

                if args.color is not None:
                    led.color = args.color.lower()

                if args.brightness is not None:
                    if args.brightness < 0 or args.brightness > 100:
                        self.error("Brightness value must be between 0 and 100")

                    led.brightness = args.brightness


class FXCommand(AbstractCommand):
    def add_parser(self, sub):
        fx = sub.add_parser('fx', help='Lighting and effects', add_help=False)
        fx.add_argument('--list', action='store_true',
                        help='List supported effects')

        fx.set_defaults(func=self.parse)
        return fx


    def _load_fx_traits(self, sfx):
        fx_traits = OrderedDict()
        for name, t_dict in sorted(sfx.items()):
            traits = dict_as_class_traits(t_dict)
            if 'hidden' in traits:
                if traits['hidden'].default_value:
                    continue
            desc = "No description available"
            if 'description' in traits:
                desc = traits['description'].default_value

            fx_traits[name] = RemoteTraits(name, desc, traits)
        return fx_traits


    def _list_fx(self, fx_traits):
        if fx_traits is None or len(fx_traits) == 0:
            self.error('No supported effects found.')

        print('\nBuilt-in effects and arguments:\n')
        keylen = max_keylen(fx_traits)

        for name, trait_data in fx_traits.items():
            print('%*s | %s' % (keylen, name, trait_data.description))
            self.show_traits(trait_data.traits, indent=keylen + 1)
            print('\n')


    def parse(self, args):
        sfx = self.driver.AvailableFX

        fxparser = ArgumentParser(description='FX Commands', conflict_handler='resolve')
        fxparser.add_argument('--list', action='store_true',
                              help='List supported effects')

        sub = fxparser.add_subparsers(title='Built-in effects', dest='fx_cmd')

        fx_traits = self._load_fx_traits(sfx)

        if args.list:
            self._list_fx(fx_traits)
            sys.exit(0)

        # turn all traits into argparse commands
        for name, trait_data in fx_traits.items():
            fx_sub = sub.add_parser(name, help=trait_data.description)
            add_traits_to_argparse(trait_data.traits, fx_sub)

        # and a "list" subcommand (same as --list)
        sub.add_parser('list')

        # parse what the main parser left behind
        args = fxparser.parse_args(self.unparsed_args)

        if args.fx_cmd is None:
            fxparser.print_help()
            sys.exit(1)

        if args.fx_cmd == 'list' or args.list:
            self._list_fx(fx_traits)
            sys.exit(0)

        # apply the traits to an empty object, which will run
        # the validators on the client
        trait_holder = HasTraits()
        traits = fx_traits[args.fx_cmd].traits
        trait_holder.add_traits(**traits)

        # apply the argparse flags to the holder object
        for name in trait_holder.traits().keys():
            if hasattr(args, name):
                value = getattr(args, name)
                if value is not None:
                    setattr(trait_holder, name, getattr(args, name))

        if self.driver.HasFX(args.fx_cmd):
            if self._activate_fx(args, args.fx_cmd, trait_holder._trait_values):
                sys.exit(0)

            self.error('Failed to activate effect')

        fxparser.print_help()
        self.error('Unsupported effect: %s\n' % args.fx_cmd)
        sys.exit(1)


    def _activate_fx(self, args, fx, tv) -> bool:
        if self.driver.HasFX(fx):
            return self.driver.SetFX(fx.lower(), dbus_prepare(tv, variant=True)[0])

        else:
            self.error('Support for this effect (%s) is not implemented' % args.fx_cmd)

        return False


class AnimationCommand(AbstractCommand):
    def __init__(self, *args, **kwargs):
        super(AnimationCommand, self).__init__(*args, **kwargs)
        self._renderer_info = None
        self._anim_args = None
        self._unparsed = None
        self._add_parser = None
        self._anim_parser = None
        self._mod_parser = None
        self._sub = None

    def add_parser(self, sub):
        self._sub = sub.add_parser('anim', help='Animation control', add_help=False)
        self._sub.set_defaults(func=self.parse)
        return self._sub


    def parse(self, args):
        self._anim_parser = ArgumentParser(description="Animation commands",
                                           parents=[self._sub])

        sub = self._anim_parser.add_subparsers(title='Animation renderers')

        sub.add_parser('list', help="List available renderers").set_defaults(func_anim=self._list)

        self._add_parser = sub.add_parser('add', help="Add a new renderer", add_help=False)
        self._add_parser.add_argument('name', type=str, help="Class name of the renderer")
        self._add_parser.add_argument('-p', '--paused', action='store_true',
                                      help="Do not immediately start")
        self._add_parser.set_defaults(func_anim=self._add)

        self._mod_parser = sub.add_parser('modify', help="Modify an existing layer", add_help=False)
        self._mod_parser.add_argument('layer', type=int, help="Layer index to modify")
        self._mod_parser.set_defaults(func_anim=self._modify)

        sub.add_parser('start', help="Start a paused animation").set_defaults(func_anim=self._start)
        sub.add_parser('stop', help="Stop the running animation").set_defaults(func_anim=self._stop)
        sub.add_parser('pause', help="Pause the animation").set_defaults(func_anim=self._pause)

        anim_args, self._unparsed = self._anim_parser.parse_known_args(self.unparsed_args)

        if not hasattr(anim_args, 'func_anim'):
            self._anim_parser.print_help()
            sys.exit(1)

        anim_args.func_anim(anim_args)


    @property
    def renderer_info(self):
        if self._renderer_info is not None:
            return self._renderer_info

        avail = self.driver.AvailableRenderers
        if avail is None or len(avail) == 0:
            self.error("No renderers available.")
            sys.exit(1)

        sar = OrderedDict(sorted(avail.items(),
                                 key=lambda k_v: k_v[1]['meta']['display_name']))
        exploded = OrderedDict()
        for name, t_anim in sar.items():
            exploded[name] = RemoteTraits(t_anim['meta']['display_name'],
                                          t_anim['meta']['description'],
                                          dict_as_class_traits(t_anim['traits']))
        self._renderer_info = exploded
        return self._renderer_info


    def _list(self, args):
        keylen = max_keylen([v.name for k, v in self.renderer_info.items()])

        print('\nAvailable renderers and arguments:\n')

        for renderer in self.renderer_info.values():
            print('%*s : %s' % (keylen, renderer.name, renderer.description))
            self.show_traits(renderer.traits, indent=keylen + 1)
            print('\n')


    def _pause(self, args):
        if not self.driver.StopAnimation():
            self.error("Failed to stop animation")


    def _stop(self, args):
        self._pause(args)
        if not self.driver.ClearRenderers():
            self.error("Failed to clear animation layers")


    def _start(self, args):
        if not self.driver.StartAnimation():
            self.error("Failed to start animation")


    def _parse_traits(self, req_anim, required: bool=False) -> dict:
        parser = ArgumentParser(description=req_anim.description,
                                parents=[self._sub],
                                conflict_handler='resolve')

        add_traits_to_argparse(req_anim.traits, parser)
        args = parser.parse_args(self._unparsed)

        changed = apply_from_argparse(args, req_anim.traits)

        if required and len(changed) == 0:
            parser.print_help()
            self.error("At least one option must be selected to modify")


    def _add(self, args):
        rname = args.name
        if rname not in self.renderer_info:
            found_short_name = False
            for k, v in self.renderer_info.items():
                if rname.lower() == v.name.lower():
                    rname = k
                    found_short_name = True
                    break

            if not found_short_name:
                self._list(args)
                self.error("%s is not a valid renderer" % (rname))

        req_anim = self.renderer_info[rname]
        traits = self._parse_traits(req_anim)

        layer = self.driver.AddRenderer(rname, dbus_prepare(traits, variant=True)[0])
        if layer is None:
            self.error("Failed to create renderer")

        print('Created layer: %s' % layer)
        if not args.paused:
            if not self.driver.StartAnimation():
                self.error("Failed to start animation")


    def _modify(self, args):

        layers = self.driver.CurrentRenderers
        if args.layer >= len(layers):
            self._list(args)
            self.error("Layer index out of range")

        req_anim = self.renderer_info[layers[args.layer][0]]
        traits = self._parse_traits(req_anim, required=True)
        layer_obj = self.client.get_layer(self.driver, args.layer)

        # Renderers expose their properties via dbus while running
        for k, v in traits.items():
            self.set_property(layer_obj, k, v)



class UChromaTool(UChromaConsoleUtil):

    COMMANDS = [DumpCommand, BrightnessCommand, LEDCommand, FXCommand, AnimationCommand]

    def _add_subparsers(self, sub):
        for command in UChromaTool.COMMANDS:
            cmd = command(self)
            cmd.add_parser(sub)



if __name__ == '__main__':
    UChromaTool().run()
